<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Star Runner - Moto Tron</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; background: #000; touch-action: none; color: white; }
        #interface { position: absolute; top: 20px; left: 20px; z-index: 10; pointer-events: none; display: none; }
        .stat-box { background: rgba(0, 0, 0, 0.8); padding: 10px 20px; border-radius: 5px; border-left: 5px solid #00d4ff; margin-bottom: 10px; }
        #target-display { font-size: 24px; color: #00d4ff; font-weight: bold; }
        #touch-controls { position: fixed; inset: 0; display: flex; z-index: 5; }
        .touch-zone { flex: 1; height: 100%; }
        
        .overlay { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; background: rgba(0, 0, 0, 0.95); padding: 40px; border: 2px solid #00d4ff; z-index: 100; min-width: 300px; }
        button { padding: 15px 40px; font-size: 20px; cursor: pointer; background: transparent; color: #00d4ff; border: 2px solid #00d4ff; font-weight: bold; margin-top: 25px; transition: 0.2s; border-radius: 8px; pointer-events: auto; }
        button:hover { background: #00d4ff; color: black; }
        
        #fireworks-canvas { position: fixed; inset: 0; pointer-events: none; z-index: 1500; display: none; }
        
        #game-over { position: fixed; inset: 0; background: black; display: none; z-index: 1000; overflow: hidden; }
        .star-wars-window { position: absolute; width: 100%; height: 100%; -webkit-mask-image: linear-gradient(to bottom, transparent 0%, black 15%, black 100%); mask-image: linear-gradient(to bottom, transparent 0%, black 15%, black 100%); }
        .crawl-container { position: absolute; bottom: 0; left: 50%; width: 300%; height: 100%; margin-left: -150%; perspective: 350px; perspective-origin: 50% 100%; }
        #crawl-text { position: absolute; width: 70%; left: 15%; top: 110%; color: #feda4a; font-family: "Franklin Gothic Medium", Arial, sans-serif; text-align: center; font-weight: 900; line-height: 1.1; transform: rotateX(20deg); transform-origin: 50% 100%; opacity: 0; }
        
        .animate-crawl { opacity: 1 !important; animation: starwars-ascend 12s linear forwards; }
        @keyframes starwars-ascend { 0% { top: 110%; transform: rotateX(20deg) translateY(0) scale(1.3); } 100% { top: -600%; transform: rotateX(20deg) translateY(-2000px) scale(0.01); } }
        #crawl-text p { margin-bottom: 1.5em; font-size: 15vw; letter-spacing: 2px; text-transform: uppercase; }
        
        #victory-screen { position: fixed; inset: 0; background: radial-gradient(circle, #001a33 0%, #000 100%); display: none; z-index: 2000; text-align: center; padding-top: 10vh; }
        .trophy { font-size: 140px; animation: bounce 2s infinite; display: block; filter: drop-shadow(0 0 20px gold); }
        @keyframes bounce { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-30px); } }
    </style>
</head>
<body>

    <canvas id="fireworks-canvas"></canvas>
    
    <div id="touch-controls">
        <div id="left-zone" class="touch-zone"></div>
        <div id="right-zone" class="touch-zone"></div>
    </div>

    <div id="start-screen" class="overlay">
        <h1>TRON RUNNER</h1>
        <p>MISSION : 12 INTERCEPTIONS (1 √Ä 100).</p>
        <p>√âCOUTEZ LE CODE EN ANGLAIS.</p>
        <button id="btn-start">ACTIVER LA GRILLE</button>
    </div>

    <div id="interface">
        <div class="stat-box"><div id="round-display">√âTAPE : 1 / 12</div></div>
        <div id="target-display">PR√âPARATION...</div>
    </div>

    <div id="game-over">
        <div class="star-wars-window">
            <div class="crawl-container">
                <div id="crawl-text">
                    <p style="font-size: 25vw; color: #feda4a; margin-bottom: 0.8em;">GAME OVER</p>
                    <p>D√©connexion du syst√®me</p>
                    <p>Le code √©tait le :</p>
                    <p style="font-size: 30vw; color: white; text-shadow: 0 0 50px #00d4ff;" id="final-target"></p>
                    <p>Fin du programme</p>
                    <p style="margin-top: 2em; font-size: 16vw;">FIN DE LIGNE</p>
                </div>
            </div>
        </div>
        <button style="position:absolute; bottom:15%; left:50%; transform:translateX(-50%); z-index:1100;" onclick="resetGame()">RECHARGER</button>
    </div>

    <div id="victory-screen">
        <span class="trophy">üèÜ</span>
        <h1 style="color: gold; font-size: 4em; text-shadow: 0 0 20px gold;">CHAMPION !</h1>
        <p style="font-size: 1.5em;">Grille compl√©t√©e avec succ√®s.</p>
        <button style="border-color: gold; color: gold;" onclick="resetGame()">REPLAY</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, ship, starsGeometry, trailMesh;
        let obstacles = [];
        let currentRound = 1, totalRounds = 12, isGameOver = false, gameActive = false, targetNumber = null;
        let keyLeft = false, keyRight = false, currentCubeSpeed = 0.35;
        let maxAnisotropy = 1;

        // Gestion de la tra√Æn√©e
        const trailPoints = [];
        const MAX_TRAIL_POINTS = 30;

        // --- Particules ---
        const fwCanvas = document.getElementById('fireworks-canvas');
        const fwCtx = fwCanvas.getContext('2d');
        let particles = [];
        function resizeFw() { fwCanvas.width = window.innerWidth; fwCanvas.height = window.innerHeight; }
        window.addEventListener('resize', resizeFw); resizeFw();

        class Particle {
            constructor(x, y, color) {
                this.x = x; this.y = y; this.color = color;
                const angle = Math.random() * Math.PI * 2;
                const velocity = Math.random() * 6 + 4;
                this.vx = Math.cos(angle) * velocity; this.vy = Math.sin(angle) * velocity;
                this.opacity = 1; this.friction = 0.95; this.gravity = 0.12;
            }
            update() {
                this.vx *= this.friction; this.vy *= this.friction; this.vy += this.gravity;
                this.x += this.vx; this.y += this.vy; this.opacity -= 0.012;
            }
            draw() {
                fwCtx.globalAlpha = Math.max(0, this.opacity); fwCtx.fillStyle = this.color;
                fwCtx.beginPath(); fwCtx.arc(this.x, this.y, 3, 0, Math.PI * 2); fwCtx.fill();
            }
        }

        function spawnFirework() {
            const x = Math.random() * fwCanvas.width;
            const y = Math.random() * fwCanvas.height * 0.4;
            const color = `hsl(${Math.random() * 360}, 100%, 65%)`;
            for(let i=0; i<80; i++) particles.push(new Particle(x, y, color));
        }

        function updateParticles() {
            fwCtx.clearRect(0, 0, fwCanvas.width, fwCanvas.height);
            for(let i = particles.length - 1; i >= 0; i--) {
                particles[i].update(); particles[i].draw();
                if(particles[i].opacity <= 0) particles.splice(i, 1);
            }
        }

        // --- Logique Audio ---
        function announceNumber(num) {
            if ('speechSynthesis' in window) {
                window.speechSynthesis.cancel();
                const utterance = new SpeechSynthesisUtterance(num.toString());
                utterance.lang = 'en-US'; 
                utterance.rate = 0.7; 
                utterance.pitch = 1.0; 
                window.speechSynthesis.speak(utterance);
            }
        }

        // Vaisseau : Moto Tron (Light Cycle)
        function createTronBike() {
            const group = new THREE.Group();
            const matBlack = new THREE.MeshPhongMaterial({ color: 0x111111, shininess: 100 });
            const matCyan = new THREE.MeshPhongMaterial({ color: 0x00d4ff, emissive: 0x00d4ff, emissiveIntensity: 1 });
            const matGlass = new THREE.MeshPhongMaterial({ color: 0x222222, transparent: true, opacity: 0.8 });

            const bodyGeo = new THREE.BoxGeometry(0.6, 0.7, 2.5);
            const body = new THREE.Mesh(bodyGeo, matBlack);
            group.add(body);

            const wheelGeo = new THREE.CylinderGeometry(0.35, 0.35, 0.55, 32);
            wheelGeo.rotateZ(Math.PI/2);
            const wheelFront = new THREE.Mesh(wheelGeo, matBlack);
            wheelFront.position.set(0, -0.1, -0.9);
            group.add(wheelFront);

            const wheelBack = new THREE.Mesh(wheelGeo, matBlack);
            wheelBack.position.set(0, -0.1, 0.9);
            group.add(wheelBack);

            const ringGeo = new THREE.TorusGeometry(0.3, 0.05, 16, 32);
            ringGeo.rotateY(Math.PI/2);
            const ringF = new THREE.Mesh(ringGeo, matCyan);
            ringF.position.set(0.28, -0.1, -0.9);
            group.add(ringF);
            const ringF2 = ringF.clone(); ringF2.position.x = -0.28;
            group.add(ringF2);

            const ringB = ringF.clone(); ringB.position.z = 0.9;
            group.add(ringB);
            const ringB2 = ringF2.clone(); ringB2.position.z = 0.9;
            group.add(ringB2);

            const stripeGeo = new THREE.BoxGeometry(0.65, 0.05, 1.8);
            const lStripe = new THREE.Mesh(stripeGeo, matCyan);
            group.add(lStripe);

            const topGeo = new THREE.BoxGeometry(0.4, 0.2, 0.8);
            const top = new THREE.Mesh(topGeo, matGlass);
            top.position.set(0, 0.4, -0.3);
            group.add(top);

            return group;
        }

        // Cr√©ation de la tra√Æn√©e (Trail)
        function createTrail() {
            const trailGeo = new THREE.PlaneGeometry(0.4, 1, 1, MAX_TRAIL_POINTS - 1);
            const trailMat = new THREE.MeshBasicMaterial({ 
                color: 0x00d4ff, 
                side: THREE.DoubleSide, 
                transparent: true, 
                opacity: 0.5 
            });
            trailMesh = new THREE.Mesh(trailGeo, trailMat);
            trailMesh.frustumCulled = false;
            scene.add(trailMesh);
        }

        function updateTrail() {
            if (!ship || !trailMesh) return;
            
            // On ajoute la position actuelle de la moto au d√©but du tableau
            trailPoints.unshift(new THREE.Vector3(ship.position.x, 0.1, ship.position.z + 1.2));
            if (trailPoints.length > MAX_TRAIL_POINTS) trailPoints.pop();

            const positions = trailMesh.geometry.attributes.position.array;
            for (let i = 0; i < trailPoints.length; i++) {
                const p = trailPoints[i];
                // On simule le recul dans le temps/espace
                const zOffset = i * currentCubeSpeed * 2; 
                
                // Point gauche du segment
                positions[i * 6 + 0] = p.x - 0.2;
                positions[i * 6 + 1] = 0.1;
                positions[i * 6 + 2] = p.z + zOffset;

                // Point droit du segment
                positions[i * 6 + 3] = p.x + 0.2;
                positions[i * 6 + 4] = 0.1;
                positions[i * 6 + 5] = p.z + zOffset;
            }
            trailMesh.geometry.attributes.position.needsUpdate = true;
        }

        function init() {
            try {
                if (typeof THREE === 'undefined') return;
                
                scene = new THREE.Scene();
                camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 1000);
                camera.position.set(0, 4, 10); camera.lookAt(0, 1.5, -5);
                
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(window.devicePixelRatio);
                document.body.appendChild(renderer.domElement);
                
                maxAnisotropy = renderer.capabilities.getMaxAnisotropy();
                scene.add(new THREE.AmbientLight(0xffffff, 0.5));
                const light = new THREE.DirectionalLight(0xffffff, 1); light.position.set(5, 10, 5); scene.add(light);
                
                ship = createTronBike(); ship.position.y = 0.8; scene.add(ship);
                createTrail();
                
                const grid = new THREE.GridHelper(600, 80, 0x00d4ff, 0x001133);
                scene.add(grid);
                
                starsGeometry = new THREE.BufferGeometry();
                const starPos = []; for(let i=0; i<1500; i++) starPos.push((Math.random()-0.5)*180, (Math.random()-0.5)*120, -Math.random()*250);
                starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starPos, 3));
                scene.add(new THREE.Points(starsGeometry, new THREE.PointsMaterial({color: 0xffffff, size: 0.15})));

                document.getElementById('btn-start').onclick = start;
                
                const lZone = document.getElementById('left-zone'); const rZone = document.getElementById('right-zone');
                if (lZone) {
                    lZone.onpointerdown = (e) => { e.preventDefault(); keyLeft = true; }; lZone.onpointerup = () => keyLeft = false;
                }
                if (rZone) {
                    rZone.onpointerdown = (e) => { e.preventDefault(); keyRight = true; }; rZone.onpointerup = () => keyRight = false;
                }
                
                window.onkeydown = (e) => { if(e.key === "ArrowLeft") keyLeft = true; if(e.key === "ArrowRight") keyRight = true; };
                window.onkeyup = (e) => { if(e.key === "ArrowLeft") keyLeft = false; if(e.key === "ArrowRight") keyRight = false; };

                animate();
            } catch (e) { console.error(e); }
        }

        function start() {
            gameActive = true; 
            document.getElementById('start-screen').style.display = 'none'; 
            document.getElementById('interface').style.display = 'block'; 
            nextRound(); 
        }

        function nextRound() {
            if (currentRound > totalRounds) { victory(); return; }
            document.getElementById('round-display').innerText = `√âTAPE : ${currentRound} / ${totalRounds}`;
            document.getElementById('target-display').innerText = "CALCUL DU SIGNAL...";
            
            obstacles.forEach(o => scene.remove(o)); obstacles = [];
            
            let nextNum;
            do { nextNum = Math.floor(Math.random() * 100) + 1; } while (nextNum === targetNumber);
            targetNumber = nextNum;

            announceNumber(targetNumber);
            document.getElementById('target-display').innerText = "INTERCEPTE LE CODE !";
            setTimeout(spawnWave, 600);
        }

        function spawnWave() {
            if(!gameActive) return;
            const lanes = [-7, 0, 7], winIdx = Math.floor(Math.random()*3);
            lanes.forEach((x, i) => {
                const val = (i === winIdx) ? targetNumber : (Math.floor(Math.random()*100)+1);
                const canv = document.createElement('canvas'); canv.width = 256; canv.height = 256; 
                const ctx = canv.getContext('2d');
                ctx.fillStyle = '#00081a'; ctx.fillRect(0,0,256,256);
                ctx.strokeStyle = '#00d4ff'; ctx.lineWidth = 15; ctx.strokeRect(10,10,236,236);
                ctx.fillStyle = '#ffffff'; ctx.font = 'bold 130px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.fillText(val, 128, 128);
                
                const tex = new THREE.CanvasTexture(canv); tex.anisotropy = maxAnisotropy;
                const box = new THREE.Mesh(new THREE.BoxGeometry(3.5, 3.5, 3.5), new THREE.MeshPhongMaterial({ map: tex }));
                box.position.set(x, 1.75, -120); 
                box.userData = { win: (i === winIdx || val === targetNumber) }; 
                scene.add(box); obstacles.push(box);
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            if (particles.length > 0) updateParticles();
            if(!gameActive || isGameOver) { renderer.render(scene, camera); return; }
            
            // Acc√©l√©ration des √©toiles proportionnelle √† la vitesse actuelle
            const starArr = starsGeometry.attributes.position.array;
            for(let i=0; i < starArr.length; i+=3) {
                starArr[i+2] += currentCubeSpeed * 12; // Vitesse de fond augment√©e
                if(starArr[i+2] > 10) starArr[i+2] = -240;
            }
            starsGeometry.attributes.position.needsUpdate = true;

            let targetRotZ = 0;
            if(keyLeft && ship.position.x > -10) { ship.position.x -= 0.6; targetRotZ = 0.5; }
            else if(keyRight && ship.position.x < 10) { ship.position.x += 0.6; targetRotZ = -0.5; }
            ship.rotation.z += (targetRotZ - ship.rotation.z) * 0.15;
            camera.position.x += (ship.position.x*0.35 - camera.position.x) * 0.1;
            
            updateTrail();

            for(let i=obstacles.length-1; i>=0; i--) {
                const b = obstacles[i];
                b.position.z += currentCubeSpeed * 2.5; // Multiplicateur pour augmenter le dynamisme
                b.rotation.y += 0.02;
                
                if(ship.position.distanceTo(b.position) < 2.5) {
                    if(b.userData.win) { 
                        currentRound++; 
                        // ACC√âL√âRATION : Vitesse des cubes augmente √† chaque √©tape
                        currentCubeSpeed += 0.04; 
                        nextRound(); 
                    } 
                    else { die(); }
                    break;
                }
                if(b.position.z > 15) {
                    if(b.userData.win) die();
                    scene.remove(b); obstacles.splice(i, 1);
                }
            }
            renderer.render(scene, camera);
        }

        function die() { 
            isGameOver = true; 
            document.getElementById('final-target').innerText = targetNumber; 
            document.getElementById('game-over').style.display = 'block'; 
            setTimeout(() => { document.getElementById('crawl-text').classList.add('animate-crawl'); }, 100);
        }

        function victory() { 
            isGameOver = true; 
            document.getElementById('victory-screen').style.display = 'block'; 
            document.getElementById('fireworks-canvas').style.display = 'block'; 
            // Les feux d'artifice sont √©galement plus rapides par d√©faut
            const launch = () => { if(isGameOver) { spawnFirework(); setTimeout(launch, 400); } }; 
            launch(); 
        }

        function resetGame() {
            isGameOver = false; gameActive = true; currentRound = 1; currentCubeSpeed = 0.35;
            document.getElementById('game-over').style.display = 'none';
            document.getElementById('victory-screen').style.display = 'none';
            document.getElementById('interface').style.display = 'block';
            document.getElementById('crawl-text').classList.remove('animate-crawl');
            document.getElementById('fireworks-canvas').style.display = 'none';
            obstacles.forEach(o => scene.remove(o)); obstacles = []; particles = []; 
            trailPoints.length = 0;
            ship.position.x = 0; nextRound();
        }

        if (document.readyState === 'complete') { init(); } else { window.addEventListener('load', init); }
    </script>
</body>
</html>
